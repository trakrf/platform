# Feature: Phase 5C - Auth Middleware & Protected Routes

## Origin
This specification completes TRA-79 (Phase 5: Authentication) by adding the final missing piece: middleware to protect existing API routes.

**Context from Phase 5 journey:**
- Phase 5A shipped: JWT + password utilities (foundation)
- Phase 5B shipped: Signup + login endpoints (user-facing API)
- Phase 5C scope: Middleware to actually USE the JWT tokens from 5B

**Key insight from conversation:**
> "Phase 5B alone is awkward to test meaningfully. The JWT doesn't DO anything useful yet without middleware. 5B + 5C together is the real unit of work."

**Testing strategy:**
- Minimal testing in 5C (quick curl validation)
- Holistic testing in Phase 6 with UI
- No security risk (localhost Docker Compose only, no production deployment)

## Outcome
Complete the authentication system by protecting all Phase 4A REST API endpoints with JWT validation.

**What changes:**
- All `/api/v1/accounts/*`, `/api/v1/users/*`, `/api/v1/account_users/*` require valid JWT
- Missing JWT → 401 Unauthorized
- Invalid/expired JWT → 401 Unauthorized
- Valid JWT → authenticated user available in request context
- Health check and auth endpoints remain public

## User Stories

**As an API consumer**
I want protected endpoints to reject unauthorized requests
So that sensitive data is not exposed without authentication

**As a backend developer**
I want authenticated user claims available in request context
So that handlers can apply business logic based on the current user

**As a system administrator**
I want clear 401 responses for auth failures
So that debugging authentication issues is straightforward

## Context

### What We Have (Phase 5A + 5B)
```go
// Phase 5A utilities
GenerateJWT(userID int, email string, currentAccountID *int) (string, error)
ValidateJWT(tokenString string) (*JWTClaims, error)

// Phase 5B endpoints
POST /api/v1/auth/signup → returns JWT
POST /api/v1/auth/login → returns JWT

// Phase 4A endpoints (currently UNPROTECTED)
GET    /api/v1/accounts
POST   /api/v1/accounts
GET    /api/v1/users
POST   /api/v1/users
// ... 13 more unprotected endpoints
```

### Current State
- JWT tokens are generated by signup/login
- Tokens contain user_id, email, current_account_id
- **But tokens aren't validated anywhere**
- Anyone can call any endpoint (no auth required)

### Desired State
- Middleware extracts JWT from Authorization header
- Middleware validates JWT using Phase 5A `ValidateJWT()`
- Valid JWT → claims injected into context → handler runs
- Invalid/missing JWT → 401 response → handler never runs
- Public endpoints (health, auth) bypass middleware

## Technical Requirements

### 1. Auth Middleware (~80 LOC)
**File:** `backend/middleware.go` (extend existing file)

**Function Signature:**
```go
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Extract Authorization header
        // Parse "Bearer {token}" format
        // Validate JWT using ValidateJWT()
        // Inject claims into context
        // Call next.ServeHTTP() or return 401
    })
}
```

**Behavior:**

1. **Extract Authorization header**
   ```go
   authHeader := r.Header.Get("Authorization")
   if authHeader == "" {
       writeJSONError(w, r, http.StatusUnauthorized, ErrUnauthorized, "Missing authorization header", "")
       return
   }
   ```

2. **Parse Bearer token**
   ```go
   parts := strings.Split(authHeader, " ")
   if len(parts) != 2 || parts[0] != "Bearer" {
       writeJSONError(w, r, http.StatusUnauthorized, ErrUnauthorized, "Invalid authorization header format", "")
       return
   }
   token := parts[1]
   ```

3. **Validate JWT**
   ```go
   claims, err := ValidateJWT(token)
   if err != nil {
       writeJSONError(w, r, http.StatusUnauthorized, ErrUnauthorized, "Invalid or expired token", "")
       return
   }
   ```

4. **Inject claims into context**
   ```go
   ctx := context.WithValue(r.Context(), UserClaimsKey, claims)
   next.ServeHTTP(w, r.WithContext(ctx))
   ```

**Context Key Pattern:**
```go
// Add to middleware.go (near existing contextKey definitions)
const UserClaimsKey contextKey = "user_claims"

// Helper for handlers to extract claims
func GetUserClaims(r *http.Request) *JWTClaims {
    if claims, ok := r.Context().Value(UserClaimsKey).(*JWTClaims); ok {
        return claims
    }
    return nil
}
```

**Error Response Format:**
- Use existing RFC 7807 `writeJSONError()` function
- Status: 401 Unauthorized
- Type: `ErrUnauthorized` (already defined in errors.go)
- Include request_id from middleware context

### 2. Protected Routes (~40 LOC)
**File:** `backend/main.go` (modify existing router setup)

**Current Structure (Unprotected):**
```go
r.Route("/api/v1", func(r chi.Router) {
    registerAuthRoutes(r)
    registerAccountRoutes(r)
    registerUserRoutes(r)
    registerAccountUserRoutes(r)
})
```

**New Structure (Protected):**
```go
r.Route("/api/v1", func(r chi.Router) {
    // Public endpoints (no auth required)
    registerAuthRoutes(r)  // signup, login

    // Protected endpoints (require valid JWT)
    r.Group(func(r chi.Router) {
        r.Use(authMiddleware)  // Apply middleware to this group

        registerAccountRoutes(r)
        registerUserRoutes(r)
        registerAccountUserRoutes(r)
    })
})
```

**Public vs Protected:**
- **Public:** `/healthz`, `/readyz`, `/health`, `/api/v1/auth/*`
- **Protected:** All Phase 4A endpoints (accounts, users, account_users)

### 3. Integration Tests (~100 LOC)
**File:** `backend/auth_middleware_test.go` (new file)

**Minimal Test Coverage (user preference for lightweight testing):**

```go
// TestAuthMiddleware_MissingToken tests 401 without Authorization header
func TestAuthMiddleware_MissingToken(t *testing.T) {
    // GET /api/v1/accounts without Authorization header
    // Assert: 401 Unauthorized
    // Assert: Error response includes "Missing authorization header"
}

// TestAuthMiddleware_InvalidToken tests 401 with malformed token
func TestAuthMiddleware_InvalidToken(t *testing.T) {
    // GET /api/v1/accounts with "Bearer invalid-token"
    // Assert: 401 Unauthorized
    // Assert: Error response includes "Invalid or expired token"
}

// TestAuthMiddleware_ValidToken tests 200 with valid JWT
func TestAuthMiddleware_ValidToken(t *testing.T) {
    // Generate valid JWT using Phase 5A GenerateJWT()
    // GET /api/v1/accounts with "Authorization: Bearer {token}"
    // Assert: 200 OK (or 500 if DB not available - that's fine)
    // Goal: Middleware passed, handler ran
}

// TestPublicEndpoints_NoAuth tests public routes work without token
func TestPublicEndpoints_NoAuth(t *testing.T) {
    // GET /healthz without Authorization header
    // GET /api/v1/auth/signup without Authorization header (OPTIONS for CORS)
    // Assert: No 401 errors
}
```

**Note:** These are **unit tests with httptest**, not full integration tests. Full end-to-end testing deferred to Phase 6 (with UI).

## Architecture Patterns

### Follow Existing Conventions
- **Middleware Pattern** - Extend `backend/middleware.go` (already has requestIDMiddleware, recoveryMiddleware, etc.)
- **Context Pattern** - Use `context.WithValue()` like existing requestIDMiddleware
- **Error Handling** - Use existing `writeJSONError()` with RFC 7807 format
- **Chi Router Groups** - Use `r.Group()` for middleware scope (chi best practice)

### New Pattern: Context Extraction Helper
```go
// In handlers that need authenticated user:
func someProtectedHandler(w http.ResponseWriter, r *http.Request) {
    claims := GetUserClaims(r)
    if claims == nil {
        // Should never happen (middleware blocks unauthenticated requests)
        writeJSONError(w, r, http.StatusInternalServerError, ErrInternal, "Missing user claims", "")
        return
    }

    userID := claims.UserID
    accountID := claims.CurrentAccountID
    // ... business logic using authenticated user
}
```

## Validation Criteria

### Functional Requirements
- [ ] Protected endpoint without JWT → 401 Unauthorized
- [ ] Protected endpoint with invalid JWT → 401 Unauthorized
- [ ] Protected endpoint with expired JWT → 401 Unauthorized
- [ ] Protected endpoint with valid JWT → handler runs (200 or other status)
- [ ] Public endpoints work without JWT (health checks, auth routes)
- [ ] Middleware injects claims into request context
- [ ] Handlers can extract claims via `GetUserClaims(r)`

### Technical Requirements
- [ ] Authorization header parsing handles missing header
- [ ] Authorization header parsing handles malformed "Bearer" format
- [ ] JWT validation uses Phase 5A `ValidateJWT()` function
- [ ] 401 responses follow RFC 7807 format
- [ ] 401 responses include request_id for tracing
- [ ] Middleware is applied to correct route groups (not global)

### Testing Requirements
- [ ] Unit tests pass (4 minimal tests)
- [ ] `just backend` validates successfully (lint, test, build)
- [ ] Quick curl validation shows expected behavior (3 commands)

### Code Quality
- [ ] Middleware follows existing patterns in middleware.go
- [ ] No code duplication (reuse writeJSONError, context patterns)
- [ ] Clear error messages for debugging
- [ ] Comments explain middleware behavior

## Quick Validation (Post-Implementation)

**3 curl commands to verify auth works:**

```bash
# 1. Protected endpoint without token → 401
curl -X GET http://localhost:8080/api/v1/accounts
# Expected: 401 with "Missing authorization header"

# 2. Signup → get token → access protected endpoint → 200
TOKEN=$(curl -X POST http://localhost:8080/api/v1/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123","account_name":"Test Co"}' \
  | jq -r '.data.token')

curl -X GET http://localhost:8080/api/v1/accounts \
  -H "Authorization: Bearer $TOKEN"
# Expected: 200 OK with accounts list (may be empty)

# 3. Public endpoint without token → 200
curl -X GET http://localhost:8080/healthz
# Expected: 200 OK
```

That's it. Full end-to-end testing happens in Phase 6 with UI.

## Success Metrics

**Completion Criteria:**
- ✅ TRA-79 (Phase 5: Authentication) complete
- ✅ All Phase 4A endpoints protected
- ✅ JWT tokens from 5B are validated in 5C
- ✅ Public endpoints remain accessible
- ✅ Ready for Phase 6 (Frontend Integration)

**Files Changed (Estimated):**
- Modified: `backend/middleware.go` (~+80 LOC for authMiddleware)
- Modified: `backend/main.go` (~+20 LOC for route grouping)
- Created: `backend/auth_middleware_test.go` (~100 LOC for 4 tests)

**Total: ~200 LOC** (smallest phase yet!)

## Out of Scope (Post-MVP)

**Not included in Phase 5C:**
- Token refresh endpoint (`POST /api/v1/auth/refresh`)
- Logout endpoint (`POST /api/v1/auth/logout`)
- Token blacklist/revocation
- Role-based access control (RBAC)
- Permission checks within handlers
- Rate limiting on auth endpoints
- Comprehensive integration tests (deferred to Phase 6)

**Rationale:** Complete core auth flow first. Add advanced features after Phase 6 stabilization.

## Testing Strategy (Conversation Context)

**User preference:**
- Skip intensive isolated testing in 5C
- Do minimal unit tests (4 tests) + quick curl validation
- Test holistically in Phase 6 with UI
- No security risk (localhost only, no production deployment)

**Reasoning:**
- 5B + 5C together form complete auth system
- Interactive testing with UI catches more issues
- Faster to test real user flows than synthetic curl scripts
- Build momentum toward visible progress (UI)

**When to add comprehensive tests:**
- After Phase 6 (when UI testing validates flows)
- Before production deployment (Phase 7+)
- As needed during stabilization

## Conversation References

**Key Insight:**
> "Phase 5B alone is awkward to test meaningfully. The JWT doesn't DO anything useful yet without middleware. 5B + 5C together is the real unit of work."

**Testing Decision:**
> "I am planning to copy over the preview setup from ../trakrf-handheld so that we can have a preview.trakrf.id after we have implemented security, stabilized the front end, and figured out the deployment"

**Deliberate Risk Assessment:**
> "Well i didnt push the merge button on 5B yet, but I'm about to. i just wanted to make sure that i was being deliberately reckless rather than carelessly reckless :)"

**Production Context:**
> "There is NO security risk until we deploy. This is all local in docker compose until phase 7. The live site is still the old nextjs app on https://trakrf.id"

## Phase 5 Completion

**When Phase 5C ships:**
- ✅ Users can signup (5B)
- ✅ Users can login (5B)
- ✅ Tokens are validated (5C)
- ✅ API is protected (5C)
- ✅ TRA-79 complete
- ✅ Ready for Phase 6 (Frontend Integration)

**The Journey:**
- 5A: Built the toolkit (utilities)
- 5B: Built the doors (endpoints)
- 5C: Locked the doors (middleware)

Now let's build the house (UI) in Phase 6.
